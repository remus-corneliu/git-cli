flags
  -u : track remote branch

Stages :
  Stage Area : files are added and begin to be tracked for any changes
  Commit Area : files are added to local repository

Concepts :
  branch : 
  HEAD : the top of the current working branch  

Commands:
  git add . : adds all changes from working directory to staging area and starts tracking.
  git commit : saves all changes from staging to local repository.
  git commit -a : directly saves to local repository files from working directory that have been already tracked.
  git push : saves to remote server all commits stored in local repository
  git fetch : gets all commits from remote repository to local repository
  git merge : applys all fetched commits 


Merge : the goal is to take commits from a source_branch (e.g. feature) and apply them to a destination_branch (e.g. master)
      : what you will end-up with if you are using merge, is that you will have a messed-up tree, looking weierd with all 
        the branching and merging.
			*
			|\
			* *
			| |
			| *
			|/
			*
			| 
			*
  git checkout master
  git merge feature

Rebase : the goal is to take commits from a source_branch (e.g. feature) and apply them to a destination_branch (e.g. master)
       : it is different from merge, it will actually take the commit history of the source_branch and will add it on top of 
         destination_branch. Basically it erases history, because of this it is hard to trace any changes added into the code-base

			*
   			|
			*
			|
			*
			|
			*
  git checkout feature
  git rebase master
	
	1st rebase against the feature, this will bring all new commints from master in to the feature and all commits from feature
	will be moved top of the master's HEAD (resolve conflicts if any)
	
  git checkout master
  git rebase feature

	2nd switch to master and rebase feature, this will bring into master what changes have been added to feature.

  git push origin/master
	
	3rd you commit changes remotely 

 
Squash : the goal is to merge into one commit multiple commits. You choose the number of commits on which you want to operate on and you
	 start interactive rebase.
	 Hit 'i' to start edit, and choose which commits are going to be squashed by marking them with 'squash'. Leave marked with 'pick'
	 the commit into which the other commits are going to be merged into, usually for avoiding conflicts you will 'pick' the last 
         commit back form the HEAD.

  git rebase -i HEAD~3

Cherry-pick :

Amend : let's say you are on a branch and you just commited something, you do a little more work and now new changes need to be staged.
        Instead of creating a new commit, and ending up with two commits you can rewrite history using the --amend flag.
	--amend operates on the last commit back from HEAD, and it will add to it the new changes.	
        --no-edit flag indicates that you don't want to rename the last commit message.
	Generates new commit Id

  git commit --amend --no-edit
	
Reword : let's say you've named your 2nd commit back from HEAD, wrongfully and you want to change its name, you can use interactive rebase
         to enter the interactive mode and select the 'reword' option on the commit which you want to operate. 
  	        You press 'i' to start editing
		Save : 'ESC', ':wq', 'Enter' 
  	 a new page pops and you can work with that commit
		You press 'i' to start editing
		Save : 'ESC', 'wq', 'Enter' 
	Generates new commit Id for the commit on which you've operated on.
        
  git rebase -i HEAD~2
	- select 'reword' 

Remove : let's say you want to delete a commit. Again you will use interactive rebase and choose the 'drop' to remove the marked commit
  	        You press 'i' to start editing
		Save : 'ESC', ':wq', 'Enter' 

Reorder : let's you reorder commits. Again you will use interactive rebase, this time you don't need to choose any option, you simply 
          switch between commits. 
  	        You press 'i' to start editing
	        Ctrl-v : copy line
		d : deletes line
		Save : 'ESC', ':wq', 'Enter' 

Squashing with fixup : just like Squash but will disregard the commit messages of the squashed commits, keeping only the message of the commit 
		       in to which they are squashed.
			      You press 'i' to start editing
			      Save : 'ESC', ':wq', 'Enter'
		       Generates new commit Id

  git rebase -i HEAD~3
	- select 'fixup'

Stash :